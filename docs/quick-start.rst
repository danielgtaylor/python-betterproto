Getting Started
===============


Compiling proto files
+++++++++++++++++++++


Given you installed the compiler and have a proto file, e.g ``example.proto``:

.. code-block:: proto

    syntax = "proto3";

    package hello;

    // Greeting represents a message you can tell a user.
    message Greeting {
      string message = 1;
    }

To compile the proto you would run the following:

.. code-block:: sh

    mkdir lib
    protoc -I . --python_betterproto_out=lib example.proto

This will generate ``lib/__init__.py`` which looks like:

.. code-block:: python

    # Generated by the protocol buffer compiler.  DO NOT EDIT!
    # sources: example.proto
    # plugin: python-betterproto
    from dataclasses import dataclass

    import betterproto


    @dataclass
    class Greeting(betterproto.Message):
        """Greeting represents a message you can tell a user."""

        message: str = betterproto.string_field(1)


Then to use it:

.. code-block:: python

    >>> from lib import Greeting

    >>> test = Greeting()
    >>> test
    Greeting(message='')

    >>> test.message = "Hey!"
    >>> test
    Greeting(message="Hey!")

    >>> bytes(test)
    b'\n\x04Hey!'

    >>> Greeting().parse(serialized)
    Greeting(message="Hey!")

    >>> another.to_dict()
    {"message": "Hey!"}
    >>> another.to_json(indent=2)
    '{\n  "message": "Hey!"\n}'

Async gRPC Support
++++++++++++++++++

The generated Protobuf Message classes are compatible with grpclib.
That said, this project also includes support for async gRPC stub generation with
better static type checking and code completion support. It is enabled by default.


Given an example service definition similar to the one below:

.. code-block:: proto

    syntax = "proto3";

    package echo;

    message EchoRequest {
      string value = 1;
      // Number of extra times to echo
      uint32 extra_times = 2;
    }

    message EchoResponse {
      repeated string values = 1;
    }

    message EchoStreamResponse  {
      string value = 1;
    }

    service Echo {
      rpc Echo(EchoRequest) returns (EchoResponse);
      rpc EchoStream(EchoRequest) returns (stream EchoStreamResponse);
    }

The generated client can be used like so:

.. code-block:: python

    import asyncio
    from grpclib.client import Channel
    import echo


    async def main():
        channel = Channel(host="127.0.0.1", port=50051)
        service = echo.EchoStub(channel)
        response = await service.echo(value="hello", extra_times=1)
        print(response)

        async for response in service.echo_stream(value="hello", extra_times=1):
            print(response)

        # don't forget to close the channel when you're done!
        channel.close()

    asyncio.run(main())  # python 3.7 only

    # outputs
    EchoResponse(values=['hello', 'hello'])
    EchoStreamResponse(value='hello')
    EchoStreamResponse(value='hello')


JSON
++++
Both serializing and parsing are supported to/from JSON and Python
dictionaries using the following methods:

Dictionaries: :meth:`betterproto.Message.to_dict`, :meth:`betterproto.Message.from_dict`

JSON: :meth:`betterproto.Message.to_json`, :meth:`betterproto.Message.from_json`


For compatibility the default is to convert field names to
:attr:`betterproto.Casing.CAMEL`. You can control this behavior by passing a
different casing value, e.g:

.. code-block:: python

    MyMessage().to_dict(casing=betterproto.Casing.SNAKE)
